#!/usr/bin/env python3

import csv
import re
import math
from peewee import *

# Database for players and their projected statistics
db = SqliteDatabase('fantasy2023.db')

class Player(Model):
    """Database entry for each player"""

    # Primary key on entry. Integer
    key = IntegerField(primary_key=True)
    # Ranking by position. This could be generated by code in the future
    posRank = IntegerField(null=True)
    # Average draft position. Requires a user entry
    adp = FloatField(null=True)
    # Round used when going through the drafting part of the code
    theround = IntegerField(null=True)
    # Pick in the round
    pick = IntegerField(null=True)
    # Position the player plays
    position = TextField()
    # NFL team
    team = TextField(null=True)
    # First and last name
    firstName = TextField()
    lastName = TextField()
    # Entered value for running backs indicating if they are a
    # 3 down back or share the backfield
    committee = TextField(null=True)
    # Fantasy team drafted to
    fanTeam = TextField(null=True)
    # Injury percentage chance from Injury Predictor website
    injury = FloatField(null=True)
    # Overall rank of the player. Requires a user entry
    ovrRank = FloatField(null=True)
    # The standard deviation of ranks since the overall ranks
    # are an average of multiple websites
    stdDevRank = FloatField(null=True)
    # Difference between rank and average draft position
    rankDiff = FloatField(null=True)
    # The number of value based drafting point over average
    vbdPoints = FloatField(null=True)
    # Projected total of points for the player.
    # Could potentially be determined by code based on exact stats
    projected = FloatField(null=True)
    # Positional reference point for value based draft analysis
    # Based on formula from websites
    vbdPosRef = FloatField(null=True)
    # Number of rank based drafting points based on same
    # formula as value based drafting
    rankPoints = FloatField(null=True)
    # Reference point for ranking
    rankPosRef = FloatField(null=True)
    # Bye Week
    bye = FloatField(null=True)
    # Calculated stdev plus VBD
    upside = FloatField(null=True)
    # Calculated VBD minus stdev
    downside = FloatField(null=True)
    # Multiplier that changes when a certain number of players from a position are drafted
    multiplier = BooleanField(null=False)

    class Meta():
        database = db


def initialize():
    """Initializes database for players"""

    db.connect()
    db.create_tables([Player], safe=True)


def scarCalc(player, away, type_tab):
    """Calculates current scarcity of position"""

    ref_players = [0, 0, 0]
    count_comparison = 0

    if type_tab == 'vbd':
        for the_player in Player.select().order_by(Player.vbdPoints.desc()).limit(away[1] + 1).where(Player.position == player.position, Player.vbdPoints <= player.vbdPoints, Player.fanTeam == None):
           
            if count_comparison == 0:
                ref_players[0] = the_player.vbdPoints

            if count_comparison in away:
                ref_players[away.index(count_comparison) + 1] = ref_players[0] - the_player.vbdPoints

            count_comparison += 1

    else:
        for the_player in Player.select().order_by(Player.rankPoints.desc()).limit(away[1] + 1).where(Player.position == player.position, Player.rankPoints <= player.rankPoints, Player.fanTeam == None):
                   
            if count_comparison == 0:
                ref_players[0] = the_player.rankPoints

            if count_comparison in away:
                ref_players[away.index(count_comparison) + 1] = ref_players[0] - the_player.rankPoints

            count_comparison += 1

    return str(int(round(ref_players[1], 0))) + ", " + str(int(round(ref_players[2], 0)))


def displayRanks(away):
    """Displays highest VBD and Rank points players remaining"""

    # Print top line header
    printTop()

    # Displays the highest rated players by VBD points
    for player in Player.select().order_by(Player.vbdPoints.desc()).limit(10).where(Player.fanTeam == None):
        printPlayer(player, 'vbd', away)

    # Prints top line header again
    printTop()

    # Displays the highest rated player by rank points
    for player in Player.select().order_by(Player.rankPoints.desc()).limit(10).where(Player.fanTeam == None):
        printPlayer(player, 'rank', away)

    print()


def posSearch(posi, away):
    """Returns top ranked players for a entered position by VBD and rank points"""

    # Print top line header
    printTop()

    # Displays the highest rated players at position by VBD points
    for player in Player.select().order_by(Player.vbdPoints.desc()).limit(10).where(Player.fanTeam == None, Player.position == posi):
        printPlayer(player, 'vbd', away)

    # Prints top line header again
    printTop()

    # Displays the highest rated player at position by rank points
    for player in Player.select().order_by(Player.rankPoints.desc()).limit(10).where(Player.fanTeam == None, Player.position == posi):
        printPlayer(player, 'rank', away)

    print()


def printTop():
    """Prints header line"""

    print()
    print("="*130)
    print("Position | First Name      | Last Name       | Team | Projected | VBD Points | Rank Points | Ovr Rank | ADP |Upside/Downside")


def printPlayer(player, type_tab, away):
    """Prints player based on database entry given to method"""

    if type_tab == 'vbd':
        print((player.position.ljust(8) +
               " | " + player.firstName.ljust(15) +
               " | " + player.lastName.ljust(15) +
               " | " + player.team.ljust(4) +
               " | " + str(player.projected).ljust(9) +
               " | " + str(player.vbdPoints).ljust(10) +
               " | " + str(player.rankPoints).ljust(11) +
               " | " + str(player.ovrRank).ljust(8) +
               " | " + str(player.adp).ljust(3) +
               " | " + str(player.upside).ljust(4) + "/" + str(player.downside).ljust(4)))

    else:
        print((player.position.ljust(8) +
               " | " + player.firstName.ljust(15) +
               " | " + player.lastName.ljust(15) +
               " | " + player.team.ljust(4) +
               " | " + str(player.projected).ljust(9) +
               " | " + str(player.vbdPoints).ljust(10) +
               " | " + str(player.rankPoints).ljust(11) +
               " | " + str(player.ovrRank).ljust(8) +
               " | " + str(player.adp).ljust(3) +
               " | " + str(player.upside).ljust(4) + "/" + str(player.downside).ljust(4)))


def playerSearch(playerName):
    """Searches for player based on first name and
    returns list of IDs followed by name and team"""

    print("Enter ID from list:")
    otherList = []

    for player in Player.select().order_by(Player.projected.desc()).where(playerName == Player.firstName):
        print(str(player.key)+". " + player.firstName + " " + player.lastName + " " + player.team)
        otherList.append(player.key)

    return otherList


def savePlayer(ourInt, ourPlayer, ourRound, ourList):
    """Saves player if entered integer is in produced list of names
    Returns a 1 to indicate player saved or 0 if the ID was not in list"""

    if ourInt in ourList:
        newTeam = Player.select().where(Player.key == ourInt).get()
        newTeam.fanTeam = ourPlayer
        newTeam.theround = ourRound
        newTeam.save()
        return 1

    else:
        print("Sorry, try again")
        return 0


def checkInt(input1):
    """Checks if an entered integer is actually an integer"""

    while True:
        input1 = input(input1).lower()

        try:
            input1 = int(input1)
            return input1
            break

        except:
            print("Not a valid number")


def tryInt(letInt):
    """Trys to return an integer. If not an integer return none"""

    try:
        return int(letInt)

    except:
        return None


def tryFloat(letFloat):
    """Trys to return a float, If not a float returns none"""

    try:
        letFloat = float(letFloat)
        return letFloat

    except:
        return None


def currentTeam(person, posList):
    """Returns current team of entered drafter"""

    print("{}'s team is:".format(person))
    print()

    try:
        for item in posList:

            for player in Player.select().where(Player.fanTeam == person, Player.position == item):
                print(player.position + " " + player.firstName + " " + player.lastName + " " + player.team)

    except:
        print("No players yet")

    print('\n')
